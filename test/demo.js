// Generated by CoffeeScript 1.6.3
(function() {

  describe('Demo', function() {
    /*
    bindTo(key, target, targetKey, noNotify):
    - 一对一, 此对象的一个key只能绑定到另一个对象
    - 多对一, 此对象的一个key可以被多个对象绑定
    - bindTo时, 默认触发一次 {property}_changed 或 changed 事件, 将noNotify设为true
    可以阻止第一次changed事件
    */

    it('BindSetNotifyKeyCallback', function() {
      var m, n, p, spy1, spy2;
      m = new MVCObject();
      n = new MVCObject();
      p = new MVCObject();
      spy1 = sinon.spy();
      spy2 = sinon.spy();
      n.k_changed = spy1;
      p.k_changed = spy2;
      n.bindTo('k', m);
      p.bindTo('k', m, 'k', true);
      m.set('k', 1);
      expect(spy1.calledTwice).to.be.ok;
      return expect(spy2.calledOnce).to.be.ok;
    });
    /*
    get(key):
    - 已经绑定过: target[getterName](key) || target.get(key)
    - 未绑定过: self[key]
    - self[getterName] 不会被调用, 当有其它对象绑定到此对象时, 在其它对象上调用get(key)时会调用此对象的self[getterName]
    - 自己原本有值, 只要绑定后, 就会被绑定过的值覆盖, 即可被覆盖的值为undefined
    */

    it('Getter', function() {
      var a, spy;
      a = new MVCObject();
      spy = sinon.spy();
      a.getX = spy;
      a.x = 2;
      expect(a.get('x')).to.equal(2);
      return expect(spy.called).to.not.be.ok;
    });
    it('GetterBind', function() {
      var a, b, spy;
      a = new MVCObject();
      spy = sinon.spy();
      a.getX = function() {
        spy();
        return 1;
      };
      b = new MVCObject();
      b.bindTo('x', a);
      expect(b.get('x')).to.equal(1);
      return expect(spy.calledOnce).to.be.ok;
    });
    it('Priority', function() {
      var a, b;
      a = new MVCObject();
      b = new MVCObject();
      a.set('k', 1);
      b.set('k', 2);
      expect(a.get('k')).to.equal(1);
      expect(b.get('k')).to.equal(2);
      a.bindTo('k', b);
      expect(a.get('k')).to.equal(2);
      return expect(b.get('k')).to.equal(2);
    });
    it('PriorityUndefined', function() {
      var a, b;
      a = new MVCObject();
      b = new MVCObject();
      a.set('k', 1);
      expect(a.get('k')).to.equal(1);
      a.bindTo('k', b);
      expect(a.get('k')).to.equal(void 0);
      return expect(b.get('k')).to.equal(void 0);
    });
    /*
        a --> b --> c
        |     |     |
    get('x')
    */

    it('Half stop search', function() {
      var a, b, c;
      a = new MVCObject;
      b = new MVCObject;
      c = new MVCObject;
      a.bindTo('m', b);
      b.bindTo('m', c);
      b.getM = function() {
        return 1;
      };
      c.getM = function() {
        return 2;
      };
      sinon.spy(b, 'getM');
      sinon.spy(c, 'getM');
      a.get('m').should.equal(1);
      b.getM.should.have.been.calledOnce;
      return c.getM.should.not.have.been.called;
    });
    /*
    set(key, value):
    - 已经绑定过, target[setterName](key, value) || target.set(key, value)
    - 未绑定过的, self[key] = value
    - self[setterName] 不会被调用, 当有其它对象绑定到此对象时, 在其它对象上调用set(key, value)时会调用此对象的self[setterName]
    */

    it('Setter', function() {
      var a, spy, x;
      a = new MVCObject();
      x = void 0;
      spy = sinon.spy();
      a.setX = spy;
      a.set('x', 1);
      expect(a.get('x')).to.equal(1);
      expect(a.x).to.equal(1);
      return expect(spy.called).to.not.be.ok;
    });
    it('SetterBind', function() {
      var a, b, spy;
      a = new MVCObject();
      spy = sinon.spy();
      a.setX = function(value) {
        this.x = value;
        return spy();
      };
      b = new MVCObject();
      b.bindTo('x', a);
      b.set('x', 1);
      expect(a.get('x')).to.equal(1);
      expect(b.get('x')).to.equal(1);
      return expect(spy.calledOnce).to.be.ok;
    });
    /*
    {property}_changed|changed
    在链的任何位置set一个值, 总是会先到达链的顶端将值保存下来,然后从顶端开始触发changed事件.
    
            a    ====>    b    ====>    c    ====>    d
                          ^             ^
                          |             |
                          |             |
                          e             f
    */

    return xit('more changed', function() {
      var a, b, c, d, e, f;
      a = new MVCObject();
      b = new MVCObject();
      c = new MVCObject();
      d = new MVCObject();
      e = new MVCObject();
      f = new MVCObject();
      a.bindTo('k', b);
      b.bindTo('k', c);
      c.bindTo('k', d);
      e.bindTo('k', b);
      f.bindTo('k', c);
      a.k_changed = function() {
        return console.log('a: k_changed');
      };
      b.k_changed = function() {
        return console.log('b: k_changed');
      };
      c.k_changed = function() {
        return console.log('c: k_changed');
      };
      d.k_changed = function() {
        return console.log('d: k_changed');
      };
      e.k_changed = function() {
        return console.log('e: k_changed');
      };
      f.k_changed = function() {
        return console.log('f: k_changed');
      };
      a.setK = function(value) {
        console.log('a: setK');
        return this.set('k', value);
      };
      b.setK = function(value) {
        console.log('b: setK');
        return this.set('k', value);
      };
      c.setK = function(value) {
        console.log('c: setK');
        return this.set('k', value);
      };
      d.setK = function(value) {
        console.log('d: setK');
        return this.set('k', value);
      };
      e.setK = function(value) {
        console.log('e: setK');
        return this.set('k', value);
      };
      f.setK = function(value) {
        console.log('f: setK');
        return this.set('k', value);
      };
      return f.set('k', 1);
    });
  });

}).call(this);
