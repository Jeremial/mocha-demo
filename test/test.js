// Generated by CoffeeScript 1.6.3
(function() {
  var
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  describe('MVCObject', function() {
    it('model', function() {
      var m;
      m = new MVCObject();
      expect(m).to.not.equal(null);
      return expect(m).to.not.equal(void 0);
    });
    it('GetUndefined', function() {
      var m;
      m = new MVCObject();
      return expect(m.get('k')).to.equal(void 0);
    });
    it('GetSetGet', function() {
      var m;
      m = new MVCObject();
      expect(m.get('k')).to.equal(void 0);
      m.set('k', 1);
      return expect(m.get('k')).to.equal(1);
    });
    it('SetValues', function() {
      var m;
      m = new MVCObject();
      m.setValues({
        k1: 1,
        k2: 2
      });
      expect(m.get('k1')).to.equal(1);
      return expect(m.get('k2')).to.equal(2);
    });
    it('NotifyCallback', function() {
      var m, spy;
      m = new MVCObject();
      spy = sinon.spy();
      m.changed = spy;
      m.notify('k');
      return expect(spy.calledOnce).to.be.ok;
    });
    it('NotifyKeyCallback', function() {
      var m, spy;
      m = new MVCObject();
      spy = sinon.spy();
      m.k_changed = spy;
      m.notify('k');
      return expect(spy.calledOnce).to.be.ok;
    });
    it('NotifyKeyEvent', function() {
      var m, spy;
      m = new MVCObject;
      spy = sinon.spy();
      m.addListener('k_changed', spy);
      m.notify('k');
      return expect(spy.calledOnce).to.be.ok;
    });
    it('SetNotifyCallback', function() {
      var m, spy;
      m = new MVCObject();
      spy = sinon.spy();
      m.changed = spy;
      m.set('k', 1);
      return expect(spy.calledOnce).to.be.ok;
    });
    it('SetNotifyKeyCallback', function() {
      var m, spy;
      m = new MVCObject();
      spy = sinon.spy();
      m.k_changed = spy;
      m.set('k', 1);
      return expect(spy.calledOnce).to.be.ok;
    });
    /*
    bindTo(key, target, targetKey, noNotify):
    - 一对一, 此对象的一个key只能绑定到另一个对象
    - 多对一, 此对象的一个key可以被多个对象绑定
    - bindTo时, 默认触发一次 {property}_changed 或 changed 事件, 将noNotify设为true
    可以阻止第一次changed事件
    */

    it('BindSetNotifyKeyCallback', function() {
      var m, n, p, spy1, spy2;
      m = new MVCObject();
      n = new MVCObject();
      p = new MVCObject();
      spy1 = sinon.spy();
      spy2 = sinon.spy();
      n.k_changed = spy1;
      p.k_changed = spy2;
      n.bindTo('k', m);
      p.bindTo('k', m, 'k', true);
      m.set('k', 1);
      expect(spy1.calledTwice).to.be.ok;
      return expect(spy2.calledOnce).to.be.ok;
    });
    it('SetNotifyKeyEvent', function() {
      var m, spy;
      m = new MVCObject;
      spy = sinon.spy();
      m.addListener('k_changed', spy);
      m.set('k', 1);
      return expect(spy.calledOnce).to.be.ok;
    });
    it('SetBind', function() {
      var m, n;
      m = new MVCObject();
      n = new MVCObject();
      m.set('k', 1);
      expect(m.get('k')).to.equal(1);
      expect(n.get('k')).to.equal(void 0);
      n.bindTo('k', m);
      expect(m.get('k')).to.equal(1);
      return expect(n.get('k')).to.equal(1);
    });
    it('BindSet', function() {
      var m, n;
      m = new MVCObject();
      n = new MVCObject();
      n.bindTo('k', m);
      m.set('k', 1);
      expect(m.get('k')).to.equal(1);
      return expect(n.get('k')).to.equal(1);
    });
    it('BindSetBackwards', function() {
      var m, n;
      m = new MVCObject();
      n = new MVCObject();
      n.bindTo('k', m);
      n.set('k', 1);
      expect(m.get('k')).to.equal(1);
      return expect(n.get('k')).to.equal(1);
    });
    it('SetBindBackwards', function() {
      var m, n;
      m = new MVCObject();
      n = new MVCObject();
      n.set('k', 1);
      n.bindTo('k', m);
      expect(m.get('k')).to.equal(void 0);
      return expect(n.get('k')).to.equal(void 0);
    });
    it('BindSetUnbind', function() {
      var m, n;
      m = new MVCObject();
      n = new MVCObject();
      n.bindTo('k', m);
      n.set('k', 1);
      expect(m.get('k')).to.equal(1);
      expect(n.get('k')).to.equal(1);
      n.unbind('k');
      expect(m.get('k')).to.equal(1);
      expect(n.get('k')).to.equal(1);
      n.set('k', 2);
      expect(m.get('k')).to.equal(1);
      return expect(n.get('k')).to.equal(2);
    });
    it('UnbindAll', function() {
      var m, n;
      m = new MVCObject();
      n = new MVCObject();
      n.bindTo('k', m);
      n.set('k', 1);
      expect(m.get('k')).to.equal(1);
      expect(n.get('k')).to.equal(1);
      n.unbindAll();
      expect(m.get('k')).to.equal(1);
      expect(n.get('k')).to.equal(1);
      n.set('k', 2);
      expect(m.get('k')).to.equal(1);
      return expect(n.get('k')).to.equal(2);
    });
    it('BindNotify', function() {
      var m, mSpy, n, nSpy;
      m = new MVCObject();
      n = new MVCObject();
      m.bindTo('k', n);
      mSpy = sinon.spy();
      m.k_changed = mSpy;
      nSpy = sinon.spy();
      n.k_changed = nSpy;
      n.set('k', 1);
      expect(mSpy.calledOnce).to.be.ok;
      return expect(nSpy.calledOnce).to.be.ok;
    });
    it('BindBackwardsNotify', function() {
      var m, mSpy, n, nSpy;
      m = new MVCObject();
      n = new MVCObject();
      n.bindTo('k', m);
      mSpy = sinon.spy();
      m.k_changed = mSpy;
      nSpy = sinon.spy();
      n.k_changed = nSpy;
      n.set('k', 1);
      expect(mSpy.calledOnce).to.be.ok;
      return expect(nSpy.calledOnce).to.be.ok;
    });
    it('BindRename', function() {
      var m, n;
      m = new MVCObject();
      n = new MVCObject();
      n.bindTo('kn', m, 'km');
      m.set('km', 1);
      expect(m.get('km')).to.equal(1);
      return expect(n.get('kn')).to.equal(1);
    });
    it('BindRenameCallbacks', function() {
      var kmSpy, knSpy, m, n;
      m = new MVCObject();
      n = new MVCObject();
      kmSpy = sinon.spy();
      m.km_changed = kmSpy;
      knSpy = sinon.spy();
      n.kn_changed = knSpy;
      n.bindTo('kn', m, 'km');
      m.set('km', 1);
      expect(m.get('km')).to.equal(1);
      expect(n.get('kn')).to.equal(1);
      expect(kmSpy.calledOnce).to.be.ok;
      return expect(knSpy.calledTwice).to.be.ok;
    });
    it('TransitiveBindForwards', function() {
      var m, n, o;
      m = new MVCObject();
      n = new MVCObject();
      o = new MVCObject();
      n.bindTo('kn', m, 'km');
      o.bindTo('ko', n, 'kn');
      m.set('km', 1);
      expect(m.get('km')).to.equal(1);
      expect(n.get('kn')).to.equal(1);
      return expect(o.get('ko')).to.equal(1);
    });
    it('TransitiveBindBackwards', function() {
      var m, n, o;
      m = new MVCObject();
      n = new MVCObject();
      o = new MVCObject();
      n.bindTo('kn', m, 'km');
      o.bindTo('ko', n, 'kn');
      o.set('ko', 1);
      expect(m.get('km')).to.equal(1);
      expect(n.get('kn')).to.equal(1);
      return expect(o.get('ko')).to.equal(1);
    });
    it('Inheritance', function() {
      var C, c, spy, _ref;
      spy = sinon.spy();
      C = (function(_super) {
        __extends(C, _super);

        function C() {
          _ref = C.__super__.constructor.apply(this, arguments);
          return _ref;
        }

        C.prototype.k_changed = spy;

        return C;

      })(MVCObject);
      c = new C();
      c.set('k', 1);
      expect(c.get('k')).to.equal(1);
      return expect(spy.calledOnce).to.equal(true);
    });
    it('MrideyAccessors', function() {
      var a, b;
      a = new MVCObject();
      a.set('level', 2);
      expect(a.get('level')).to.equal(2);
      b = new MVCObject();
      b.setValues({
        level: 2,
        index: 3,
        description: 'Hello world'
      });
      return expect(b.get('index')).to.equal(3);
    });
    it('MrideyBinding', function() {
      var a, b, c;
      a = new MVCObject();
      a.set('level', 2);
      b = new MVCObject();
      b.bindTo('index', a, 'level');
      expect(b.get('index')).to.equal(2);
      a.set('level', 3);
      expect(b.get('index')).to.equal(3);
      b.set('index', 4);
      expect(a.get('level')).to.equal(4);
      c = new MVCObject();
      c.bindTo('zoom', a, 'level');
      expect(c.get('zoom')).to.equal(4);
      b.unbind('index');
      expect(b.get('index')).to.equal(4);
      c.set('zoom', 5);
      expect(a.get('level')).to.equal(5);
      return expect(b.get('index')).to.equal(4);
    });
    it('CircularBind', function() {
      var a, b;
      a = new MVCObject();
      b = new MVCObject();
      a.bindTo('k', b);
      return expect(function() {
        return b.bindTo('k', a);
      }).to["throw"]();
    });
    /*
    set(key, value):
    - 已经绑定过, target[setterName](key, value) || target.set(key, value)
    - 未绑定过的, self[key] = value
    - self[setterName] 不会被调用, 当有其它对象绑定到此对象时, 在其它对象上调用set(key, value)时会调用此对象的self[setterName]
    */

    it('Setter', function() {
      var a, spy, x;
      a = new MVCObject();
      x = void 0;
      spy = sinon.spy();
      a.setX = spy;
      a.set('x', 1);
      expect(a.get('x')).to.equal(1);
      expect(a.x).to.equal(1);
      return expect(spy.called).to.not.be.ok;
    });
    it('SetterBind', function() {
      var a, b, spy;
      a = new MVCObject();
      spy = sinon.spy();
      a.setX = function(value) {
        this.x = value;
        return spy();
      };
      b = new MVCObject();
      b.bindTo('x', a);
      b.set('x', 1);
      expect(a.get('x')).to.equal(1);
      expect(b.get('x')).to.equal(1);
      return expect(spy.calledOnce).to.be.ok;
    });
    /*
    get(key):
    - 已经绑定过: target[getterName](key) || target.get(key)
    - 未绑定过: self[key]
    - self[getterName] 不会被调用, 当有其它对象绑定到此对象时, 在其它对象上调用get(key)时会调用此对象的self[getterName]
    - 自己原本有值, 只要绑定后, 就会被绑定过的值覆盖, 即可被覆盖的值为undefined
    */

    it('Getter', function() {
      var a, spy;
      a = new MVCObject();
      spy = sinon.spy();
      a.getX = spy;
      a.x = 2;
      expect(a.get('x')).to.equal(2);
      return expect(spy.called).to.not.be.ok;
    });
    it('GetterBind', function() {
      var a, b, spy;
      a = new MVCObject();
      spy = sinon.spy();
      a.getX = function() {
        spy();
        return 1;
      };
      b = new MVCObject();
      b.bindTo('x', a);
      expect(b.get('x')).to.equal(1);
      return expect(spy.calledOnce).to.be.ok;
    });
    it('Priority', function() {
      var a, b;
      a = new MVCObject();
      b = new MVCObject();
      a.set('k', 1);
      b.set('k', 2);
      expect(a.get('k')).to.equal(1);
      expect(b.get('k')).to.equal(2);
      a.bindTo('k', b);
      expect(a.get('k')).to.equal(2);
      return expect(b.get('k')).to.equal(2);
    });
    it('PriorityUndefined', function() {
      var a, b;
      a = new MVCObject();
      b = new MVCObject();
      a.set('k', 1);
      expect(a.get('k')).to.equal(1);
      a.bindTo('k', b);
      expect(a.get('k')).to.equal(void 0);
      return expect(b.get('k')).to.equal(void 0);
    });
    /*
        a --> b --> c
        |     |     |
    get('x')
    */

    it('Half stop search', function() {
      var a, b, c;
      a = new MVCObject;
      b = new MVCObject;
      c = new MVCObject;
      a.bindTo('m', b);
      b.bindTo('m', c);
      b.getM = function() {
        return 1;
      };
      c.getM = function() {
        return 2;
      };
      sinon.spy(b, 'getM');
      sinon.spy(c, 'getM');
      a.get('m').should.equal(1);
      b.getM.should.have.been.calledOnce;
      return c.getM.should.not.have.been.called;
    });
    it('BindSelf', function() {
      var a;
      a = new MVCObject();
      return expect(function() {
        return a.bindTo('k', a);
      }).to["throw"]();
    });
    it('ChangedKey', function() {
      var a, spy;
      a = new MVCObject();
      spy = sinon.spy();
      a.changed = spy;
      a.set('k', 1);
      return expect(spy.calledWith('k')).to.be.ok;
    });
    /*
    {property}_changed|changed
    在链的任何位置set一个值, 总是会先到达链的顶端将值保存下来,然后从顶端开始触发changed事件.
    
            a    ====>    b    ====>    c    ====>    d
                          ^             ^
                          |             |
                          |             |
                          e             f
    */

    return xit('more changed', function() {
      var a, b, c, d, e, f;
      a = new MVCObject();
      b = new MVCObject();
      c = new MVCObject();
      d = new MVCObject();
      e = new MVCObject();
      f = new MVCObject();
      a.bindTo('k', b);
      b.bindTo('k', c);
      c.bindTo('k', d);
      e.bindTo('k', b);
      f.bindTo('k', c);
      a.k_changed = function() {
        return console.log('a: k_changed');
      };
      b.k_changed = function() {
        return console.log('b: k_changed');
      };
      c.k_changed = function() {
        return console.log('c: k_changed');
      };
      d.k_changed = function() {
        return console.log('d: k_changed');
      };
      e.k_changed = function() {
        return console.log('e: k_changed');
      };
      f.k_changed = function() {
        return console.log('f: k_changed');
      };
      a.setK = function(value) {
        console.log('a: setK');
        return this.set('k', value);
      };
      b.setK = function(value) {
        console.log('b: setK');
        return this.set('k', value);
      };
      c.setK = function(value) {
        console.log('c: setK');
        return this.set('k', value);
      };
      d.setK = function(value) {
        console.log('d: setK');
        return this.set('k', value);
      };
      e.setK = function(value) {
        console.log('e: setK');
        return this.set('k', value);
      };
      f.setK = function(value) {
        console.log('f: setK');
        return this.set('k', value);
      };
      return f.set('k', 1);
    });
  });

}).call(this);
